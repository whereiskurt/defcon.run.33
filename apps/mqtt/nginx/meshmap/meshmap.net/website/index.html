<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="description" content="A nearly live map of Meshtastic nodes seen by the official Meshtastic MQTT server">
<title>ðŸ¥• run.defcon.run</title>
<link rel="preload" href="/map/nodes.json" as="fetch" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900">
<link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<link rel="manifest" href="/map/site.webmanifest">
<style>
  html, body, #map {
    height: 100%;
    width: 100vw;
  }
  body {
    margin: 0;
    padding: 0;
  }
  body.dark {
    filter: invert(1) hue-rotate(180deg) brightness(1.25);
  }
  body.dark .dark-hidden {
    display: none;
  }
  body:not(.dark) .dark-only {
    display: none;
  }
  body.ghost-mode {
    filter: hue-rotate(90deg) saturate(1.5);
  }
  body.ghost-mode.dark {
    filter: invert(1) hue-rotate(270deg) brightness(1.25) saturate(1.5);
  }
  #header {
    background-color: #fff;
    box-shadow: 0 0 4px 0 rgb(0 0 0 / 40%);
    color: #333;
    display: flex;
    align-items: center;
    gap: 2ch;
    font-family: "Inter", sans-serif;
    padding: 0.75em;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
  }
  #header a {
    color: inherit;
    text-decoration: none;
  }
  #header a:hover {
    opacity: 0.7;
  }
  body.dark #header {
    background-color: #333;
    color: #fff;
    box-shadow: 0 0 4px 0 rgb(255 255 255 / 20%);
    filter: invert(1) hue-rotate(180deg) brightness(1.25);
  }
  #header div:nth-child(2) {
    flex-grow: 1;
    text-align: right;
  }
  table {
    border-collapse: collapse;
  }
  table :is(th, td) {
    text-align: left;
    vertical-align: top;
  }
  table :is(th, td):nth-child(n+2) {
    padding-left: 1em;
  }
  .break {
    word-break: break-all;
  }
  .leaflet-top {
    top: 80px;
  }
  .leaflet-tooltip, .leaflet-popup-content {
    font-family: "Inter", sans-serif;
    font-size: 12px;
  }
  .leaflet-popup-content .title {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 3px;
  }
  .leaflet-popup-content table {
    margin-top: 1em;
  }
  body.dark .leaflet-shadow-pane {
    display: none;
  }
  body.dark :is(.leaflet-tooltip, .leaflet-popup-content-wrapper, .leaflet-popup-tip) {
    box-shadow: 0 0 4px 0 rgb(0 0 0 / 40%);
  }
  @media (hover: none) {
    .leaflet-tooltip-pane {
      display: none;
    }
  }
</style>
<div id="header">
  <div>
    <a href="https://run.defcon.run" target="_blank" title="run.defcon.run" style="font-size: 1.5em; font-weight: bold;">ðŸ¥•&nbsp;run.defcon.run</a>
  </div>
  <div>
    <a
      href="#"
      onclick="const newTheme = document.body.classList.toggle('dark') ? 'dark' : 'light'; window.localStorage.setItem('theme', newTheme); if (previousTheme !== newTheme) { previousTheme = newTheme; if (themeToggleTimeout) clearTimeout(themeToggleTimeout); themeToggleCount++; if (themeToggleCount >= REQUIRED_TOGGLES) { toggleMobileMode('theme'); themeToggleCount = 0; } else { themeToggleTimeout = setTimeout(() => { themeToggleCount = 0; }, TOGGLE_TIMEOUT); } } return false"
      title="Toggle dark mode"
    ><i class="fa fa-moon-o dark-hidden" style="font-size: 36px;"></i><i class="fa fa-sun-o dark-only" style="font-size: 36px;"></i></a>
  </div>
  <div><a href="https://defcon.meshtastic.org/" target="_blank" title="DefCon33 Meshtastic">
    <img src="dc33-logo-transp.webp" alt="DefCon 33 Logo" style="height: 36px; vertical-align: middle;">
  </a></div>
  <div><a href="https://github.com/brianshea2/meshmap.net" title="Meshmap Source Code"><i class="fa fa-github" style="font-size: 36px;"></i></a></div>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.js"></script>
<script src="https://unpkg.com/leaflet-search@4.0.0/dist/leaflet-search.min.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script>
  const updateInterval = 30000
  const zoomLevelNode = 10
  const markersByNode = {}
  const neighborsByNode = {}
  const nodesBySearchString = {}
  
  // Special sequence and mode state
  let mobileMode = false
  const keySequence = []
  let sequenceTimeout = null
  const SPECIAL_SEQUENCE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a']
  
  // Theme toggle tracking for mobile mode
  let themeToggleCount = 0
  let themeToggleTimeout = null
  let previousTheme = window.localStorage.getItem('theme') || 'light'
  const REQUIRED_TOGGLES = 10
  const TOGGLE_TIMEOUT = 4000
    
  // Generate marker color based on shortName
  const getMarkerColorFromNodeName = (shortName, longName) => {

    if (!shortName || !longName) {
      return '#ff0000'; // Default to red if shortName or longName is invalid
    }

    // In mobile mode, always use Matrix green
    if (mobileMode) {
      return '#00ff00';
    }

    if (longName.includes('dc33.east')) {
      return "purple"
    } else if (longName.includes('dc33.bigstar')) {
      return "darkblue"
    } else if (longName.includes('dc33.')) {
      return "orange"
    }

    return '#ff0000'; // Default to red if no conditions are met
  }
  
  // Array of colors for random marker selection (kept for backward compatibility)
  const markerColors = ['red', 'blue', 'green', 'orange', 'violet', 'grey', 'black']
  // Get a consistent color based on node number
  const getNodeColor = nodeNum => markerColors[parseInt(nodeNum) % markerColors.length]
  const precisionMargins = [
    11939464, 5969732, 2984866, 1492433, 746217, 373108, 186554, 93277,
    46639, 23319, 11660, 5830, 2915, 1457, 729, 364,
    182, 91, 46, 23, 11, 6, 3, 1,
    1, 0, 0, 0, 0, 0, 0, 0
  ]
  // encodes html reserved characters and ascii control characters
  const html = str => str
    ?.replace(/[\x00-\x1F]/g, c => `\\x${c.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0')}`)
    .replace(/["&<>]/g, c => `&#${c.charCodeAt(0)};`)
  // makes more human-readable time duration strings
  const duration = d => {
    let s = ''
    if (d > 86400) {
      s += `${Math.floor(d / 86400)}d `
      d %= 86400
    }
    if (d > 3600) {
      s += `${Math.floor(d / 3600)}h `
      d %= 3600
    }
    s += `${Math.floor(d / 60)}min`
    return s
  }
  const since = t => `${duration(Date.now() / 1000 - t)} ago`
  // Function to toggle mobile mode
  const toggleMobileMode = (triggerType) => {
    mobileMode = !mobileMode
    
    // Toggle body class for visual effect
    document.body.classList.toggle('ghost-mode', mobileMode)
    
    // Visual feedback flash
    const flash = document.createElement('div')
    flash.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: ${mobileMode ? '#00ff00' : '#ff0000'};
      color: #000;
      padding: 20px 40px;
      border-radius: 10px;
      font-size: 18px;
      font-weight: bold;
      z-index: 9999;
      pointer-events: none;
      opacity: 0.9;
      box-shadow: 0 0 20px ${mobileMode ? '#00ff00' : '#ff0000'};
      text-shadow: 0 0 5px ${mobileMode ? '#00ff00' : '#ff0000'};
    `
    flash.textContent = mobileMode ? atob('R0hPU1QgTU9ERSBBQ1RJVkFURUQ=') : atob('R0hPU1QgTU9ERSBERUFDVElWQVRFRA==')
    document.body.appendChild(flash)
    
    setTimeout(() => {
      if (document.body.contains(flash)) {
        document.body.removeChild(flash)
      }
    }, 1500)
    
    if (mobileMode) {
      const x = btoa('meshctf'), y = 'user', z = 'accomplishments';
      fetch(`${location.protocol}//${location.hostname.replace('mqtt', 'run')}/api/${y}/${z}?type=${atob(x)}`, {
        credentials: 'include'
      }).then(r => r.json()).then(d => {
        const h = 'bW9iaWxlbW9kZV9vbl9tZXNobWFw';
        if (!d[z] || !d[z].some(a => a.name && a.name.includes(atob(h)))) {
          setTimeout(() => window.open(`${location.protocol}//${location.hostname.replace('mqtt', 'run')}/qr/${atob(h)}`, '_blank'), 100);
        }
      }).catch(() => {
        const h = 'bW9iaWxlbW9kZV9vbl9tZXNobWFw';
        setTimeout(() => window.open(`${location.protocol}//${location.hostname.replace('mqtt', 'run')}/qr/${atob(h)}`, '_blank'), 100);
      });
    }
    
    // Clear existing markers and redraw the map with new filter
    markers.clearLayers()
    Object.keys(markersByNode).forEach(key => delete markersByNode[key])
    Object.keys(nodesBySearchString).forEach(key => delete nodesBySearchString[key])
    drawMap()
  }
  
  // set theme
  if (window.localStorage.getItem('theme') === 'dark') {
    document.body.classList.add('dark')
  }
  // init map
  const map = L.map('map', {
    center: window.localStorage.getItem('center')?.split(',') ?? [25, 0],
    zoom: window.localStorage.getItem('zoom') ?? 2,
    zoomControl: false,
    worldCopyJump: true,
  })
  // add tiles
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    maxZoom: 19,
  }).addTo(map)
  // add marker group
  const markers = L.markerClusterGroup({
    disableClusteringAtZoom: zoomLevelNode,
    spiderfyOnMaxZoom: false,
  }).addTo(map)
  // add node details layer (neighbor lines, precision circle)
  const detailsLayer = L.layerGroup().addTo(map)
  map.on('click', () => detailsLayer.clearLayers())
  // add search control
  map.addControl(new L.Control.Search({
    layer: markers,
    propertyName: 'searchString',
    initial: false,
    position: 'topleft',
    marker: false,
    moveToLocation: (_, s) => showNode(nodesBySearchString[s]),
  }))
  // add zoom control
  L.control.zoom({position: 'topright'}).addTo(map)
  
  // Key sequence listener
  window.addEventListener('keydown', (e) => {
    if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
      return
    }
    
    if (sequenceTimeout) {
      clearTimeout(sequenceTimeout)
    }
    
    const key = e.key === 'B' ? 'b' : e.key === 'A' ? 'a' : e.key
    
    keySequence.push(key)
    if (keySequence.length > SPECIAL_SEQUENCE.length) {
      keySequence.shift()
    }
    
    if (keySequence.length === SPECIAL_SEQUENCE.length &&
        keySequence.every((key, index) => key === SPECIAL_SEQUENCE[index])) {
      toggleMobileMode('sequence')
      keySequence.length = 0
    }
    
    sequenceTimeout = setTimeout(() => {
      keySequence.length = 0
    }, 10000)
  })
  // add geolocation control
  L.easyButton({
    position: 'topright',
    states: [
      {
        stateName: 'geolocation-button',
        title: 'Center map to current IP geolocation',
        icon: 'fa-crosshairs fa-lg',
        onClick: () => {
          fetch(`https://ipinfo.io/json`)
            .then(r => r.json())
            .then(({loc}) => loc && map.flyTo(loc.split(','), zoomLevelNode))
            .catch(e => console.error('Failed to set location:', e))
        },
      },
    ],
  }).addTo(map)
  // track and store map position
  map.on('moveend', () => {
    const center = map.getCenter()
    window.localStorage.setItem('center', [center.lat, center.lng].join(','))
  })
  map.on('zoomend', () => {
    window.localStorage.setItem('zoom', map.getZoom())
  })
  // generates html for a node link
  const nodeLink = (num, label) => `<a href="#${num}" onclick="showNode(${num});return false">${html(label)}</a>`
  // updates node map markers
  const updateNodes = data => Object.entries(data).forEach(([nodeNum, node]) => {
    const {
      longName, shortName, hwModel, role,
      fwVersion, region, modemPreset, hasDefaultCh, onlineLocalNodes,
      latitude, longitude, altitude, precision,
      batteryLevel, voltage, chUtil, airUtilTx, uptime,
      temperature, relativeHumidity, barometricPressure, lux,
      windDirection, windSpeed, windGust, radiation, rainfall1, rainfall24,
      neighbors, seenBy
    } = node
    
    // Filter based on mobile mode
    const longNameLower = (longName || '').toLowerCase();
    const shortNameLower = (shortName || '').toLowerCase();
    const isGhostNode = longNameLower.includes('ghost') || longNameLower.includes('contest') || longNameLower.includes('operative') || shortNameLower.startsWith('ghost');
    
    if (mobileMode) {
      // In mobile mode, only show ghost nodes
      if (!isGhostNode) {
        return; // Skip non-ghost nodes
      }
    } else {
      // In normal mode, exclude ghost nodes
      if (isGhostNode) {
        return; // Skip ghost nodes
      }
    }
    const id = `!${Number(nodeNum).toString(16)}`
    neighborsByNode[nodeNum] ??= new Set()
    if (neighbors) {
      Object.keys(neighbors).forEach(neighborNum => {
        neighborsByNode[neighborNum] ??= new Set()
        neighborsByNode[neighborNum].add(nodeNum)
        neighborsByNode[nodeNum].add(neighborNum)
      })
    }
    const position = L.latLng([latitude, longitude].map(x => x / 10000000))
    const lastSeen = Math.max(...Object.values(seenBy))
    const opacity = 1.0 - (Date.now() / 1000 - lastSeen) / 129600
    const tooltipContent = `${html(longName)} (${html(shortName)}) ${since(lastSeen)}`
    const popupContent = `
      <div class="title">${html(longName)} (${html(shortName)})</div>
      <div>${nodeLink(nodeNum, id)} | ${html(role)} | ${html(hwModel)}</div>
      <table><tbody>
      ${fwVersion          ? `<tr><th>Firmware</th><td>${html(fwVersion)}</td></tr>`                               : ''}
      ${region             ? `<tr><th>Region</th><td>${html(region)}</td></tr>`                                    : ''}
      ${modemPreset        ? `<tr><th>Modem preset</th><td>${html(modemPreset)}</td></tr>`                         : ''}
      ${hasDefaultCh       ? `<tr><th>Has default channel</th><td>True</td></tr>`                                  : ''}
      ${onlineLocalNodes   ? `<tr><th>Online local nodes</th><td>${onlineLocalNodes}</td></tr>`                    : ''}
      ${batteryLevel       ? `<tr><th>Power</th><td>${batteryLevel > 100 ? 'Plugged in' : `${batteryLevel}%`}` +
                             `${voltage ? ` (${voltage.toFixed(2)}V)` : ''}</td></tr>`                             : ''}
      ${chUtil             ? `<tr><th>ChUtil</th><td>${chUtil.toFixed(2)}%</td></tr>`                              : ''}
      ${airUtilTx          ? `<tr><th>AirUtilTX</th><td>${airUtilTx.toFixed(2)}%</td></tr>`                        : ''}
      ${uptime             ? `<tr><th>Uptime</th><td>${duration(uptime)}</td></tr>`                                : ''}
      ${temperature        ? `<tr><th>Temperature</th><td>${temperature.toFixed(1)}&#8451; / ` +
                             `${(temperature * 1.8 + 32).toFixed(1)}&#8457;</td></tr>`                             : ''}
      ${relativeHumidity   ? `<tr><th>Relative Humidity</th><td>${Math.round(relativeHumidity)}%</td></tr>`        : ''}
      ${barometricPressure ? `<tr><th>Barometric Pressure</th><td>${Math.round(barometricPressure)} hPa</td></tr>` : ''}
      ${lux                ? `<tr><th>Lux</th><td>${Math.round(lux)} lx</td></tr>`                                 : ''}
      ${windDirection || windSpeed ? `<tr><th>Wind</th><td>` +
                              (windDirection ? `${windDirection}&#176;` : '') +
                              (windDirection && windSpeed ? ' @ ' : '') +
                              (windSpeed ? `${(windSpeed * 3.6).toFixed(1)}` : '') +
                              (windSpeed && windGust ? ` G ${(windGust * 3.6).toFixed(1)}` : '') +
                              (windSpeed ? ' km/h' : '') +
                              `</td></tr>`                                                                         : ''}
      ${radiation          ? `<tr><th>Radiation</th><td>${radiation.toFixed(2)} ÂµR/h</td></tr>`                    : ''}
      ${rainfall1 || rainfall24 ? `<tr><th>Rainfall</th><td>` +
                              (rainfall1 ? `${rainfall1.toFixed(2)} mm/h` : '') +
                              (rainfall1 && rainfall24 ? ', ' : '') +
                              (rainfall24 ? `${rainfall24.toFixed(2)} mm/24h` : '') +
                              `</td></tr>`                                                                         : ''}
      ${altitude           ? `<tr><th>Altitude</th><td>${altitude.toLocaleString()} m above MSL</td></tr>`         : ''}
      ${precision && precisionMargins[precision-1] ? `<tr><th>Location precision</th><td>` +
                             `&#177;${precisionMargins[precision-1].toLocaleString()} m (orange circle)</td></tr>` : ''}
      </tbody></table>
      <table><thead>
      <tr><th>Last seen</th><th>via</th><th>root topic</th><th>channel</th></tr>
      </thead><tbody>
      ${Array.from(
        new Map(
          Object.entries(seenBy)
            .map(([topic, seen]) => (m => ({seen, via: m[3] ?? id, root: m[1], chan: m[2]}))(
              topic.match(/^(.*)(?:\/2\/e\/(.*)\/(![0-9a-f]+)|\/2\/map\/)$/s)
            ))
            .sort((a, b) => a.seen - b.seen)
            .map(v => [v.via, v])
        ).values(),
        ({seen, via, root, chan}) => `
          <tr>
          <td>${since(seen)}</td>
          <td>${via !== id ? (num => data[num] ? nodeLink(num, via) : via)(parseInt(via.slice(1), 16)) : 'self'}</td>
          <td class="break">${html(root)}</td>
          <td class="break">${html(chan ?? 'n/a (MapReport)')}</td>
          </tr>
        `
      ).reverse().join('')}
      </tbody></table>
    `
    const populateDetailsLayer = () => {
      detailsLayer.clearLayers()
      if (precision && precisionMargins[precision-1]) {
        L.circle(position, {radius: precisionMargins[precision-1], color: '#ffa932'})
          .addTo(detailsLayer)
      }
      neighborsByNode[nodeNum].forEach(neighborNum => {
        if (markersByNode[neighborNum] === undefined) {
          return
        }
        const neighborId = `!${Number(neighborNum).toString(16)}`
        const neighborContent = `
          <table><tbody>
          <tr><th>Neighbor</th><td>${html(id)} &#60;-&#62; ${html(neighborId)}</td></tr>
          <tr><th>Distance</th><td>${Math.round(map.distance(position, markersByNode[neighborNum].getLatLng())).toLocaleString()} m</td></tr>
          ${neighbors?.[neighborNum]?.snr ? `<tr><th>SNR</th><td>${neighbors[neighborNum].snr} dB</td></tr>` : ''}
          ${neighbors?.[neighborNum]?.updated ? `<tr><th>Last seen</th><td>${since(neighbors[neighborNum].updated)}</td></tr>` : ''}
          </tbody></table>
        `
        L.polyline([position, markersByNode[neighborNum].getLatLng()], {weight: 4})
          .bindTooltip(neighborContent, {sticky: true})
          .on('click', () => showNode(neighborNum))
          .addTo(detailsLayer)
      })
    }
    if (markersByNode[nodeNum] === undefined) {
      
      // Generate color based on shortName
      const markerColor = shortName ? getMarkerColorFromNodeName(shortName, longName) : '#ff0000'
      
      // Use ghost icon for ghost nodes when mobile mode is enabled
      const useGhostIcon = mobileMode && isGhostNode;
      
      const iconSettings = useGhostIcon ? {
        mapIconUrl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 120"><path fill="{ghostColor}" stroke="#FFF" stroke-width="3" d="M50 10 C30 10 15 25 15 45 L15 80 C15 85 17 88 20 85 L25 80 C28 77 32 77 35 80 L40 85 C43 88 47 88 50 85 L55 80 C58 77 62 77 65 80 L70 85 C73 88 77 88 80 85 L85 80 C88 77 85 85 85 80 L85 45 C85 25 70 10 50 10 Z"/><circle fill="#000" cx="35" cy="40" r="5"/><circle fill="#000" cx="65" cy="40" r="5"/><ellipse fill="#000" cx="50" cy="60" rx="8" ry="10"/></svg>',
        ghostColor: markerColor,
      } : {
        mapIconUrl: '<svg version="1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 149 178"><path fill="{mapIconColor}" stroke="#FFF" stroke-width="6" stroke-miterlimit="10" d="M126 23l-6-6A69 69 0 0 0 74 1a69 69 0 0 0-51 22A70 70 0 0 0 1 74c0 21 7 38 22 52l43 47c6 6 11 6 16 0l48-51c12-13 18-29 18-48 0-20-8-37-22-51z"/><circle fill="{mapIconColorInnerCircle}" cx="74" cy="75" r="61"/><circle fill="#FFF" cx="74" cy="75" r="{pinInnerCircleRadius}"/></svg>',
        mapIconColor: markerColor,
        mapIconColorInnerCircle: markerColor,
        pinInnerCircleRadius: 32
      }

      const startPin = L.divIcon({
        className: "leaflet-data-marker",
        html: L.Util.template(iconSettings.mapIconUrl, iconSettings),
        iconAnchor: useGhostIcon ? [15, 36] : [12, 32],
        iconSize: useGhostIcon ? [30, 36] : [25, 30],
        popupAnchor: useGhostIcon ? [0, -36] : [0, -28]
      })

      const searchString = `${longName} (${shortName}) ${id}`
      nodesBySearchString[searchString] = nodeNum
      markersByNode[nodeNum] = L.marker(position, {
        alt: 'Node', 
        opacity, 
        searchString, 
        icon: startPin,
      })
        .bindTooltip(tooltipContent)
        .bindPopup(popupContent, {maxWidth: 500})
        .on('popupopen', () => {
          history.replaceState(null, '', `#${nodeNum}`)
          populateDetailsLayer()
        })
        .addTo(markers)
    } else {
      markersByNode[nodeNum].setOpacity(opacity)
      markersByNode[nodeNum].setTooltipContent(tooltipContent)
      markersByNode[nodeNum].setPopupContent(popupContent)
      markersByNode[nodeNum].setLatLng(position)
      if (markersByNode[nodeNum].isPopupOpen()) {
        populateDetailsLayer()
      }
    }
  })
  // fetches node data, updates map, repeats
  const drawMap = async () => {
    try {
      await fetch('/map/nodes.json').then(r => r.json()).then(updateNodes)
    } catch (e) {
      console.error('Failed to update nodes:', e)
    }
    setTimeout(() => {
      if (document.hidden) {
        document.addEventListener('visibilitychange', drawMap, {once: true})
      } else {
        drawMap()
      }
    }, updateInterval)
  }
  // centers map to node and opens popup
  const showNode = nodeNum => {
    if (markersByNode[nodeNum] === undefined) {
      return false
    }
    map.setView(markersByNode[nodeNum].getLatLng(), Math.max(window.localStorage.getItem('zoom') ?? 0, zoomLevelNode))
    setTimeout(() => markersByNode[nodeNum].openPopup(), 300)
    return true
  }
  // keep URL fragment in sync
  window.addEventListener('hashchange', () => {
    if (window.location.hash && !showNode(window.location.hash.slice(1))) {
      history.replaceState(null, '', window.location.pathname)
    }
    if (!window.location.hash) {
      map.closePopup()
    }
  })
  map.on('popupclose', () => {
    if (window.location.hash) {
      history.replaceState(null, '', window.location.pathname)
    }
  })
  // let's go!!!
  drawMap().then(() => {
    if (window.location.hash && !showNode(window.location.hash.slice(1))) {
      history.replaceState(null, '', window.location.pathname)
    }
  })
</script>
